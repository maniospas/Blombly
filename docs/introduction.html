<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Blombly Companion - Introduction</title>
    <link rel="stylesheet" rel="prefetch" href="style.css">
    <link rel="stylesheet" rel="prefetch" href="prism.css">
</head>
<body>
<div class="sidebar">
    <h2>Blombly Companion</h2>
    <a rel="prefetch" href="index.html">Home</a>
    <a rel="prefetch" href="introduction.html" style="color: orange;">Introduction</a>
    <p><strong>Set things up</strong></p>
    <a rel="prefetch" href="hello-world.html">1.1 Hello world!</a>
    <a rel="prefetch" href="errors.html">1.2 Errors</a>
    <p><strong>Basic features</strong></p>
    <a rel="prefetch" href="vars-operations-comments.html">2.1 Vars, operations, comments</a>
    <a rel="prefetch" href="control-flow.html">2.2 Control flow</a>
    <a rel="prefetch" href="code-blocks-inline.html">2.3 Code blocks & inline</a>
    <a rel="prefetch" href="calling-blocks.html">2.4 Calling blocks</a>
    <a rel="prefetch" href="structs.html">2.5 Structs</a>
    <p><strong>Advanced features</strong></p>
    <a rel="prefetch" href="preprocessor.html">3.1 Preprocess (include, macro)</a>
    <a rel="prefetch" href="success-fail.html">3.2 Signals (try, return)</a>
    <a rel="prefetch" href="return-from-new.html">3.3 Return from new</a>
    <a rel="prefetch" href="overloading.html">3.4 Overloading</a>
</div>
<button class="toggle-button" onclick="toggleSidebar()">☰</button>
<h1>Introduction</h1>

<p>
There are many programming languages for writing dynamic yet safe code. You might 
already have a favorite one! However, safety often comes at the cost complexity, 
like mutability restrictions.
Blombly is a simple language with a small set of instructions. It is focused on 
algorithmic logic by automating tasks like memory 
management and parallelization. It thus simplifies safe code without
being overly restrictive. That said, the language's design 
follows a "one solution" principle; there should be one obvious way to implement
code in most situations. The language compiles into an intermediate representation that is interpreted by 
the <i><strong>BLO</strong>ck ase<strong>MBLY</strong> <strong>V</strong>irtual 
<strong>M</strong>achine</i> (blomblyVM). The intermediate language
ensures reliability by replacing jump-based statements to entering and exiting
code blocks. This includes managing control flow via conditions, loops, inlining,
method calling, return statements for successful operations, and error messages for failures.
</p>

<p>
So, who is Blombly for? It might be a good choice if you want to:
</p>
<ul>
    <li>✅ Quickly learn a dynamic scripting language.</li>
    <li>✅ Write sequential code that runs in parallel.</li>
    <li>✅ Ensure memory and logic safety by design.</li>
</ul>

<h3>A short demo</h3>
<p>
Below is a small blombly program showcasing several basic language features.
These include some object-oriented macros declared in the file <code>std/oop.bb</code>
of the standard library, namely the <code>module</code> and <code>fn</code> macros.
In particular, the program begins by creating a module (that is, a new stuct) 
named <code>xy</code>, which includes several code blocks that perform transformations.
An adder function inlines those transformations while intercepting any
return values (though there are none in this code) or errors with the
<code>try</code> clause. In case there is an error, this is handled in the
<code>catch</code> statement. The method is called by combining positional
arguments with code that is executed and transferred to the memory context.
This call determines dynamically which transformation should be inlined,
as well as the transformation's parameters.
</p>

<pre><code class="language-java">#include "std/oop"

module xy {
    scale = {
        default factor = 1;  // set if not found
        if(factor&lt;=0)  // Omit implied brackets
            fail("Scale factor should be > 0, got: "+str(factor));
        x = x*factor;
        y = y*factor;
    }
    normalize = {
        norm = (x^2+y^2)^0.5;
        if(norm==0)
            fail("Cannot normalize a zero norm");
        x = x/norm;
        y = y/norm;
    }
}

fn adder(x, y) {  // this is a macro for final adder(x,y) = {...}
    err = try transform: // `try` intercepts errors or returns, `:` inlines execution
    catch(err) {
        print("Intercepted an error: " +str(err));
        return 0;
    }
    return x+y;
}

result = adder(1,2 | transform=xy.scale; factor=1);  // Calls run in parallel
print(result);
</code></pre>


<!-- Navigation buttons -->
<div class="nav-buttons">
    <a href="index.html" class="nav-button">Home</a>
    <a href="hello-world.html" class="nav-button">→</a>
</div>

<script src="prism.min.js"></script>
<script src="prism-java.min.js"></script>
<script>
    function toggleSidebar() {
        document.body.classList.toggle('show-sidebar');
    }
</script>
</body>
</html>
