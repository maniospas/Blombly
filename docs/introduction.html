<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Blombly Companion - Introduction</title>
    <link rel="stylesheet" rel="prefetch" href="style.css">
    <link rel="stylesheet" rel="prefetch" href="prism.css">
</head>
<body>
<div class="sidebar">
    <h2>Blombly Companion</h2>
    <a rel="prefetch" href="index.html">Home</a>
    <a rel="prefetch" href="introduction.html" style="color: orange;">Introduction</a>
    <p><strong>Set things up</strong></p>
    <a rel="prefetch" href="hello-world.html">1.1 Hello world!</a>
    <a rel="prefetch" href="errors.html">1.2 Errors</a>
    <p><strong>Basic features</strong></p>
    <a rel="prefetch" href="vars-operations-comments.html">2.1 Vars, operations, comments</a>
    <a rel="prefetch" href="control-flow.html">2.2 Control flow</a>
    <a rel="prefetch" href="code-blocks-inline.html">2.3 Code blocks & inline</a>
    <a rel="prefetch" href="calling-blocks.html">2.4 Calling blocks</a>
    <a rel="prefetch" href="structs.html">2.5 Structs</a>
    <p><strong>Advanced features</strong></p>
    <a rel="prefetch" href="preprocessor.html">3.1 Preprocess (include, macro)</a>
    <a rel="prefetch" href="success-fail.html">3.2 Signals (try, return)</a>
    <a rel="prefetch" href="return-from-new.html">3.3 Return from new</a>
    <a rel="prefetch" href="overloading.html">3.4 Overloading</a>
</div>
<button class="toggle-button" onclick="toggleSidebar()">☰</button>
<h1>Introduction</h1>

<p>
There are many programming languages for writing dynamic, safe code. You might 
already have a favorite! However, ensuring safety often adds complexity, like 
managing memory or dealing with concurrency issues.
Blombly is a simple language with a small set of instructions focused on 
algorithmic logic. It automates non-algorithmic tasks, such as memory 
management and parallelization, making it easier to write safe code. Blombly 
follows a "one solution" principle—if there’s an obvious way to do something, 
there’s likely no alternative.
</p>

<p>
The main language compiles into an intermediate representation, interpreted by 
the <i><strong>BLO</strong>ck ase<strong>MBLY</strong> <strong>V</strong>irtual 
<strong>M</strong>achine</i> (blomblyVM). This virtual machine uses block-based 
assembly instructions to ensure reliability by avoiding jump statements. 
Control flow is managed through code blocks, making it easier to apply safety 
constraints. Control flow mechanisms consist of conditions, loops, inlining,
method calling, return statements for successful operations, and error messages for failures.
</p>

<p>
So, who is Blombly for? It might be a good choice if you want to:
</p>
<ul>
    <li>✅ Quickly learn a dynamic scripting language.</li>
    <li>✅ Write sequential code that runs in parallel.</li>
    <li>✅ Ensure memory and logic safety by design.</li>
</ul>

<h3>A short demo</h3>
<p>
Below is a small Blombly program showcasing several basic language features. 
While practical code can be more explicit (like when using the "std/oop" library 
for object-oriented programming), this example keeps things simple.
</p>

<pre><code class="language-java">final scaler = {  // Immutable block, visible across method calls
    default scale = 1;
    if(scale&lt;=0)  // Omit implied brackets
       fail("Scale should be > 0, got: "+str(scale));
    if(scale&lt1) {
        scale = 1/scale;
        print("Warning: Inverted the scale.");
    }
}

final add(x,y) = {
    signal = try scaler: // `:` runs inline, `try` catches errors
    catch(signal) {
        print("Handled an error.");
        return 0;
    }
    return (x + y)*scale;
}

result = add(1, 2 | scale=0);  // Calls run in parallel
print(result);
</code></pre>

<p>
This program begins by creating a code block to handle the <code>scale</code> 
variable, with a default value of 1 if none is provided and checks if the scale 
is valid (greater than 0) and adjusts it if necessary. The block is declared 
<code>final</code>, meaning it can't be changed and is accessible from other 
method calls.
Another code block performs addition and multiplication using the scale. It
also uses the <code>scaler:</code> block inline and intercepts any 
errors that occur during execution. The <code>catch</code> mechanism works 
similarly to an <code>if</code> statement, but it is triggered by errors instead 
of boolean conditions.
Finally, the <code>add</code> block is called with positional arguments. 
Variables after the <code>|</code> symbol during the call are passed along 
ith the arguments, allowing for flexible inline code, for example to initialize several
calls with the same configurations. These calls are automatically scheduled for 
parallel execution, with access to only transferred values and 
<code>final</code> variables.
</p>

<!-- Navigation buttons -->
<div class="nav-buttons">
    <a href="index.html" class="nav-button">Home</a>
    <a href="hello-world.html" class="nav-button">→</a>
</div>

<script src="prism.min.js"></script>
<script src="prism-java.min.js"></script>
<script>
    function toggleSidebar() {
        document.body.classList.toggle('show-sidebar');
    }
</script>
</body>
</html>
