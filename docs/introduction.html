<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Blombly Companion - Introduction</title>
    <link rel="stylesheet" rel="prefetch" href="style.css">
    <link rel="stylesheet" rel="prefetch" href="prism.css">
</head>
<body>
<div class="sidebar">
    <h2>Blombly Companion</h2>
    <a rel="prefetch" href="index.html">Home</a>
    <a rel="prefetch" href="introduction.html" style="color: orange;">Introduction</a>
    <p><strong>Set things up</strong></p>
    <a rel="prefetch" href="hello-world.html">1.1 Hello world!</a>
    <a rel="prefetch" href="errors.html">1.2 Errors</a>
    <p><strong>Basic features</strong></p>
    <a rel="prefetch" href="vars-operations-comments.html">2.1 Vars, operations, comments</a>
    <a rel="prefetch" href="control-flow.html">2.2 Control flow</a>
    <a rel="prefetch" href="code-blocks-inline.html">2.3 Code blocks & inline</a>
    <a rel="prefetch" href="calling-blocks.html">2.4 Calling blocks</a>
    <a rel="prefetch" href="structs.html">2.5 Structs</a>
    <a rel="prefetch" href="success-fail.html">2.6 Success-error handling</a>
    <p><strong>Advanced features</strong></p>
    <a rel="prefetch" href="return-from-new.html">3.1 Return from new</a>
    <a rel="prefetch" href="overloading.html">3.2 Overloading</a>
</div>
<button class="toggle-button" onclick="toggleSidebar()">☰</button>
<h1>Introduction</h1>

<p>
There are a lot of programming languages out there offering the ability to create dynamic 
yet safe code - maybe you are already thinking of your favorite one. A common
characteristic of these languages is that they require extensive familiarization and their
safety features may be harder to work with compared to unsafe features or languages. 
For example, memory safety typically requires modifications to pure algorithmic logic, 
where the programmer needs to worry about non-functional code characteristics, 
like deadlocks and race conditions, that would be absent from single-threaded unsafe languages.
</p>
<p>
Blombly is a programming language with a reduced instruction set and algorithm-only semantics.
This means that it is limited to a few but powerful operations that cover a
broad range of scenarios. At the same time, tasks like memory management and parallelization 
are automated under-the-hood. The main language is compiled into an intermediate respresentation 
that is interpreted by an accompanying 
<i><strong>BLO</strong>ck ase<strong>MBLY</strong> <strong>V</strong>irtual <strong>M</strong>achine</i> 
(blomblyVM). The latter parses block-based assembly instructions that ensure reliability through
the absense of jump statements; flow constrol is performed through code blocks of asembly instructions 
that are easier to apply safety constraints on.
</p>
<p>
So, who is this language for? It may be a good idea to look at blombly if your aim is one of the following:<br><br>

✅ Quickly learn a dynamic (duck-typed) scripting language.<br>
✅ Write sequential code that runs in parallel.<br>
✅ Ensure memory safety by design.<br>
</p>


<h3>A short demo</h3>
<p>
Below is a small blombly program that showcases several language features.
First, there is a code block that creates a <code>scale</code> variable with a provided default,
if it does not already exist (we will see momentarily how it might exist). Then, the code block
creates an error message if a non-positive scale is provided. The code block declaration does not run any code, 
but only creates a variable holding the block for future use. It is made <code>final</code> so that it 
cannot be modified. Similarly, a code block that performs addition and multiplication with some scale is provided.
This takes as input two positional arguments <code>x,y</code>.
This block also uses the <code>scaler:</code> symbol to inline the namesake. Inlining constitutes of 
immediately calling the other block's code, as if it were pasted already.
</p>

<p>
Inlining is further enriched by enclosing it an a <code>try</code> statement (the brackets can be inferred
by the language, but they are there for clarity). This statement is responsible for intercepting errors and inline return
values, and then places the intercepted values in the variable <code>signal</code>. The <code>catch</code>
catch mechanism is the equivalent of <code>if</code>, with the difference that it is entered if it encounters an error
instead of boolean truth. For safety, unhandled error values create further errors if they are never handled.
</p>

<p>
The code block is called like a method. It takes positional arguments per normal, but there can also be
programming statements to create more variables after a <code>|</code> separator. These statements
look like positional variables separated by semicolons, but by being fully fleshed code they offer greater flexibility.
For example, they can inline the same configuration code block across several methods. Any variables created after 
<code>|</code> are transferred to the called <code>add</code> block together with the positional arguments. Blocks can be called
with only or no positional arguments too. They are also scheduled to run in autonomous execution in threads, from where
they have access only to their positional arguments, transferred variables, and <code>final</code> variables.
</p>

<pre><code class="language-java">final scaler = {
    default scale = 1;
    if(scale&lt;=0)
       error("Scale should be greater than zero, but another value was given: "+str(scale));
}

final add(x,y) = {
    signal = try{scaler:}
    catch(signal) {
        print("handled an error");
        return 0;
    }
    return (x + y)*scale;
}

result = add(1, 2 | scale=0);
print(result);
</code></pre>



<script src="prism.min.js"></script>
<script src="prism-java.min.js"></script>
<script>
    function toggleSidebar() {
        document.body.classList.toggle('show-sidebar');
    }
</script>
</body>
</html>
