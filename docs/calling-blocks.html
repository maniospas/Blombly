<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Blombly Companion - Calling Blocks</title>
    <link rel="stylesheet" rel="prefetch" href="style.css">
    <link rel="stylesheet" rel="prefetch" href="prism.css">
</head>
<body>
<div class="sidebar">
    <h2>Blombly Companion</h2>
    <a rel="prefetch" href="index.html">Home</a>
    <a rel="prefetch" href="introduction.html">Introduction</a>
    <p><strong>Set things up</strong></p>
    <a rel="prefetch" href="hello-world.html">1.1 Hello world!</a>
    <a rel="prefetch" href="errors.html">1.2 Errors</a>
    <p><strong>Basic features</strong></p>
    <a rel="prefetch" href="vars-operations-comments.html">2.1 Vars, operations, comments</a>
    <a rel="prefetch" href="control-flow.html">2.2 Control flow</a>
    <a rel="prefetch" href="code-blocks-inline.html">2.3 Code blocks & inline</a>
    <a rel="prefetch" href="calling-blocks.html"  style="color: orange;">2.4 Calling blocks</a>
    <a rel="prefetch" href="structs.html">2.5 Structs</a>
    <a rel="prefetch" href="success-fail.html">2.6 Success-error handling</a>
    <p><strong>Advanced features</strong></p>
    <a rel="prefetch" href="return-from-new.html">3.1 Return from new</a>
    <a rel="prefetch" href="overloading.html">3.2 Overloading</a>
</div>
<button class="toggle-button" onclick="toggleSidebar()">â˜°</button>
<h1>Calling blocks</h1>

<p>
here are two mechanisms for creating callable code blocks (aka methods)
in blombly. The first relies on directly calling defined blocks by passing
variables as keyword arguments. The second modifies block definitions so
that they accept keyword arguments too (or only keyword arguments).
</p>

<h3>Calling with keyword arguments</h3>

<p>
Code blocks defined in blombly can have a mixture and be called like methods by injecting values 
as keyword arguments separated by semicolons (because in truth the arguments
constitute a bracketless code block, but more on this later). 
The last argument may be a list (values separated by commas), which the 
intepreter assign to the <i>args</i> keyword.  
When not transforming data, it is recommended to
stick to keywords for better readability and maintainability 
per the principles of forward-oriented programming that blombly follows. 
For example, keyword arguments create a sense of the functional
role of each argument for those reading code.
</p>
<p>
All calls run in parallel, but details of this orchestration are purposefully 
hidden so that you can write code as if all method calls were fully sequential 
instead. In addition to their arguments, running code blocks can access <i>final</i> 
values from the scope of their declaration.
</p>

<p>
The <i>return</i> keyword ends block execution with the corrosponding returning 
value. That value are intercepted by the block call in the scope of this section.
However, the return signal may also intercepted by the <i>new</i> mechanism of the 
<a rel="prefetch" href="structs.html">next section</a> and the <i>try</i> mechanism 
of <a rel="prefetch" href="success-fail.html">section 2.6</a>. 
Beware the inlining such blocks transfers their return statements to parent blocks too.
</p>

<p>
The example below defines a simple addition block and calls it with 
pecific values for <i>x</i> and <i>y</i>: The particular declaration is made <i>final</i>
for logic safety, but this does not need to always be the case.
</p>

<i>main.bb</i>
<pre><code class="language-java">final add = {
    return x + y;
}

result = add(x=1; y=2);
print(result);
</code></pre>


<p>
In fact, you can have any code block there (by exception, it does not need brackets) and it 
will run without affecting the current scope while keeping any assignments to be prepended to the block's
execution.
</p>

<h3>Calling with positional arguments</h3>

<p>
Blombly also supports calling blocks using comma-separated positional arguments.
This is a familiar programming language pattern, and there are two ways to enable it
by retrieving positional values withing called blocks. The lower-level option is to make 
use of the  <code>args</code> variable generated by the compiler, which expressly holds 
positional arguments as a list. You can then access list elements or use <code>next</code> 
to obtain their values (reminder that this pops the first list element). 
An example of this coding pattern is shown below.
</p>

<i>main.bb</i>
<pre><code class="language-java">final add = {
    x = next(args);
    y = next(args);
    return x + y;
}

result = add(1, 2);
print(result);
</code></pre>

<p>
A second and higher-level way of preparing code blocks for calling with positional arguments
is to add argument names inside a parenethesis next to the block's name, separated by comma. 
This does not modify the block's name and the latter be assigned to other variables per normal
or used for inlining (provided a local <code>args</code> variable).
The following example is equivalent to the previous one. Although <code>next</code> removes
the two entries of the provided arguments, you can still access the rest if more are provided
in the call.
</p>

<i>main.bb</i>
<pre><code class="language-java">final add(x, y) = { // shorthand for popping these values
    return x + y;
}
test = add; // can still transfer the definition this way

result = test(1, 2);
print(result);
</code></pre>


<h3>Mixing the two types of arguments</h3>


<p>
Blombly allows mixing of positional and "keyword" arguments in a single call
with a pattern that reads similarly to conditional probabilities <code>name(args | kwargs)</code>
where args are the positional arguments and kwargs the bracketless code block that is used
to generate the keyword arguments. Positional arguments are generated
first from the calling scope, and can therefore modify the <Code>args</Code> if needed.
</p>

<p>
In the following example, the block <code>add</code> is defined with two parameters, 
<code>x</code> and <code>y</code>, and two default parameters, <code>wx</code> and <code>wy</code>. 
When calling <code>add</code>, we pass the numbers <code>1</code> and <code>2</code> as positional 
arguments, which are internally matched to <code>x</code> and <code>y</code>. Knowing
the details about default parameters is not necessary at the point where the decision to use the
block is made.
</p>

    

<i>main.bb</i>
<pre><code class="language-java">final add(x, y) = {
    default wx = 1;
    default wy = 1;
    return x*wx + y*wy;
}

result = add(1,2 | wx=1;wy=2);
print(result);
</code></pre>
    

<script src="prism.min.js"></script>
<script src="prism-java.min.js"></script>
<script>
    function toggleSidebar() {
        document.body.classList.toggle('show-sidebar');
    }
</script>
</body>
</html>
