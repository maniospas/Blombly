<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Blombly Companion - Return from New</title>
    <link rel="stylesheet" rel="prefetch" href="style.css">
    <link rel="stylesheet" rel="prefetch" href="prism.css">
</head>
<body>
<div class="sidebar">
    <h2>Blombly Companion</h2>
    <a rel="prefetch" href="index.html">Home</a>
    <a rel="prefetch" href="introduction.html">Introduction</a>
    <a rel="prefetch" href="demo.html">Showcase</a>
    <p><strong>Set things up</strong></p>
    <a rel="prefetch" href="hello-world.html">1.1 Hello world!</a>
    <a rel="prefetch" href="errors.html">1.2 Errors</a>
    <p><strong>Basic features</strong></p>
    <a rel="prefetch" href="vars-operations-comments.html">2.1 Vars, operations, comments</a>
    <a rel="prefetch" href="control-flow.html">2.2 Control flow</a>
    <a rel="prefetch" href="code-blocks-inline.html">2.3 Code blocks & inline</a>
    <a rel="prefetch" href="calling-blocks.html">2.4 Calling blocks</a>
    <a rel="prefetch" href="structs.html">2.5 Structs</a>
    <p><strong>Advanced features</strong></p>
    <a rel="prefetch" href="preprocessor.html">3.1 Preprocess (include, macro)</a>
    <a rel="prefetch" href="success-fail.html">3.2 Signals (try, return)</a>
    <a rel="prefetch" href="return-from-new.html" style="color: orange;">3.3 Return from new</a>
    <a rel="prefetch" href="overloading.html">3.4 Overloading</a>
</div>
<button class="toggle-button" onclick="toggleSidebar()">☰</button>
<h1>Return from new</h1>

<p>Return statements from within <code>new {...}</code> statements change the
retrieved value to something other than a struct. For example, the following snippet
is a valid (though not efficient in terms of asymptotic complexity) method for recursively
computing a term of the Fibonacci sequence. BlomblyVM always schedules <code>new</code> for 
direct execution, that is, without spawning a separate thread. In general, though,
prefer usage of this statement to create structs.</p>

<i>main.bb</i>
<pre><code class="language-java">final fib = {  // make it final so that it can see itself
    if(n&lt;2){return 1;} 
    return new{n = n-1;fib:} + new{n = n-2;fib:};
}

tic = time();
print("Result", fib(n=21));
print("Time", time()-tic);</code></pre>

<p>One particular wrinkle to iron out in our understanding is what it means
to return a code block that is later used as a method. This is the same behavior
as returning from code blocks called as methods with the result being 
another block. To maintain memory safety, all returned blocks are detached
from their declaring scope. While being scopeless, they can only be inlined.
However, they can also get re-attached to a new scope by either setting them
as struct fields (in which case they are attached to the struct)
or creating new blocks that inline them. An example of the last pattern
is presented below:
</p>

<pre><code class="language-java">final method = new {
    final message = "Declared in a first scope";
    final printer = {
        print(message);
    }
    return printer;
}
final obj = new {
    final message = "Declared in an object";
}

final message = "Declared in external scope";
rebased_method = {method:}
obj.method = method;

rebased_method();
obj.method();
method();  // CREATES AN ERROR
</code></pre>

<p>Let's run the code. BlomblyVM executes the
first two calls in parallel, and their internal prints are performed 
in unspecified order given that there is no sycnhronization mechanism. 
hen, the final block call
fails to execute due to having being detached from a memory context. An
ambridged version of this section describes prospective options.</p>

<pre class="code-output">> blombly main.bb
(<span class="ok"> OK </span>) Preprocessing
(<span class="ok"> OK </span>) Compilation
(<span class="ok"> OK </span>) Optimization
Declared in an object
Declared in external scope
(<span class="error"> ERROR </span>) Memoryless code block cannot be called.
   !!! Returned code blocks are not attached to any
       memory context to use its finals. Consider these options:
       - Set `\call=block;` to make the struct callable.
       - Set the block as an object field and call that. It can
         also be set as a field of another object.
       - Inline the returned block. For example, `rebased={block:}`
         rebases it to the current context.
       Recursive calls could be violated if you assign to a different
       name. No option is automated to prevent ambiguity.
   <span class="arrow">→</span> call _bb15 # method                         main.bbvm line 32
</pre>

<p>The question, then, persists of how to create callables that depend
on their own internal state. This can be achieved with operation
overloading that turns structs into callables. This is presented 
in the next section.
</p>

<!-- Navigation buttons -->
<div class="nav-buttons">
    <a href="success-fail.html" class="nav-button">←</a>
    <a href="overloading.html" class="nav-button">→</a>
</div>

<script src="prism.min.js"></script>
<script src="prism-java.min.js"></script>
<script>
    function toggleSidebar() {
        document.body.classList.toggle('show-sidebar');
    }
</script>
</body>
</html>
